# TravelEase: AI coding agent conventions

- Scope: productive, code-aware guidance for modifying and extending TravelEase frontend and backend (Amplify React UI + CDK-based AWS backend).
- Purpose: capture the essential patterns, data contracts, and workflow steps visible in the repo so an AI agent can act confidently without re-deriving architecture.

- References are anchored to concrete files in this repo (paths shown in code blocks).

Big picture

- Frontend: a React + TypeScript SPA built with Vite that uses AWS Amplify for configuration and (via a custom API) submits a travel form. See `src/ContactForm.tsx` and `src/amplifyConfig.ts`.
- Backend: an AWS CDK TypeScript project (`travel_backend/`) that deploys two stacks: `TravelBackendStack` (data plane + API) and `SesStack` (SES identity). See `travel_backend/lib/travel_backend-stack.ts` and `travel_backend/lib/ses-stack.ts`.
- Data path: UI collects form fields, posts to API Gateway endpoint (POST /submit), Lambda handles the event, stores in DynamoDB, queues or emails as needed, and responds with a result.

- Infra wiring snapshot (key points):
- DynamoDB table: `travelease-form` with partition key `submission_id` (created in `TravelBackendStack`).
- SQS queue: `TravelBackendQueue` for decoupled processing.
- Lambda: `ContactFormLambda` (Python 3.11) wired with env vars: `SQS_QUEUE_URL`, `DYNAMODB_TABLE_NAME`, `SOURCE_EMAIL`, `TO_EMAIL`, `OWNER_EMAIL`.
- HTTP API: `/submit` route backed by `ContactFormLambda` via `HttpLambdaIntegration`.
- SES: identity configured in `SesStack` and permissions granted to the Lambda for sending emails.

- Contract anchors (examples)
- Frontend form fields: `name`, `email`, `phone`, `inquiry_type`, `message` are sent; backend expects `submission_id` generated by backend and returned in the response. See `src/ContactForm.tsx` and the API contract in the Lambda (e.g. `event['body']` parsing).
- Amplify wiring: the frontend loads Amplify configuration from `src/amplifyConfig.ts` which imports `amplify_outputs.json` via `outputs` and does `Amplify.configure(outputs)`. See:

```
import outputs from '../amplify_outputs.json';
Amplify.configure(outputs);
```

- The client-side model/schema is accessed via:

```
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource';
const client = generateClient<Schema>();
```

and the `Schema` type is defined in `src/amplify/data/resource`.

- Frontend behavior pattern (example):
- Submits form data to `https://<api-domain>/submit` using `fetch` with JSON body:

```
const formData = { name, email, phone, inquiry_type: inquiryType, message };
fetch(`${apiEndpoint}/submit`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(formData) });
```

- Running and testing (local workflows)
- Frontend: `TravelEase` -> `npm install` -> `npm run dev` (Vite dev server). See `TravelEase/package.json`.
- Backend: `travel_backend` -> `npm ci` (install CDK deps) -> `npx cdk synth` / `npx cdk diff` / `npx cdk deploy` (deploy stacks) as described in `travel_backend/README.md`.
- Tests: Node tests in `travel_backend/test_ses.js` and Python tests in `travel_backend/test_ses.py` (see `travel_backend/TEST_SES.md`).

- Project conventions and patterns
- CDK structure: two stacks `TravelBackendStack` (data + API) and `SesStack`. See `TravelBackendStack` which creates:
  - DynamoDB table `travelease-form` (partition key `submission_id`)
  - SQS queue `TravelBackendQueue`
  - Python Lambda `ContactFormLambda` with env vars and SES permissions
  - HTTP API route POST `/submit` -> Lambda integration
  - Outputs: `QueueUrl`, `TableName`, `ApiEndpoint`, SES info
- SES wiring: `SesStack` defines an SES email identity used by the Lambda to send emails (see `travel_backend/lib/ses-stack.ts`).
- Data contracts: form submission schema is persisted in DynamoDB; response includes `submission_id`.
- Cross-component communication: frontend -> API Gateway -> Lambda -> DynamoDB/SES; notes on identity ARN scope in IAM policy.

- Extending the codebase (quick guide)
- Add a new form field: update frontend `ContactForm.tsx` payload and update DynamoDB table key/schema if needed; update Lambda to read the extra field and store it.
- Change email sender/recipients: adjust `SOURCE_EMAIL` / `TO_EMAIL` / `OWNER_EMAIL` env vars in `TravelBackendStack` and corresponding Lambda code in `travel_backend/lambda/app.py`.
- Add a new API route: extend `TravelBackendStack` with a new `HttpApi` route and integrate with a new Lambda handler, following the existing pattern for `/submit`.

- Quick caveats
- The provided Lambda code in `travel_backend/lambda/app.py` is a reference; ensure it matches your deployed stack (the file in repo shows some placeholders and may require alignment with the real `form_data` shape used by the stack).
- This repo uses AWS CDK v2; build and deploy steps live under `travel_backend` per its `README.md`.
